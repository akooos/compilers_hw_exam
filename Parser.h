// Generated by Bisonc++ V4.12.03 on Sat, 17 Oct 2015 13:02:48 +0200

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"
#include "FlexLexer.h"

#undef Parser
class Parser: public ParserBase
{
        
    public:
	/*2. Lexikális elemző konstruktorát meghívom és átadom a cin meg a cerr-t */
        Parser( std::istream & in):ParserBase(),lexer( &in, &std::cerr ),sorszam(0){};
        int parse();

    private:
        bool isDeclared( const std::string &id ) const;	
	/*3.  Szimbólumtábla adattag*/
	SymbolsTable tblSymbols;
       /* 1. Lexikális elemzőt felveszem statikus adattagként  */ 
        yyFlexLexer lexer;
        void error(char const *msg);    // called on (syntax) errors
	/*2. Leimplemtálom a lex() függvényt ez adja vissza a következő tokent vagy a hibát */
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

        unsigned int sorszam;
        unsigned int getSorszam(){
            ++sorszam;
            return sorszam;
        }
        void error(const std::stringstream &strm);
        void errorRedeclaredVar(const std::string &id){		
		std::stringstream ss;
		ss  << "Ujradeklaralt valtozo:\"" << id << "\"" << std::endl << "Korabbi deklaracio sora: " << tblSymbols[ id ].decl_row << std::endl ; 
		error(ss);
	}
        void errorVarNotDeclared(const std::string &id){		
		std::stringstream ss;
		ss  << "Nem deklarált változó: \"" << id << "\""<< std::endl ; 
		error(ss);
	}
        void errorMismatchTypesInExpression(){		
		std::stringstream ss;
		ss  << "Hibás típus(ok) a kifejezésban"  << std::endl ; 
		error(ss);
	}
        void errorLogicalExpExpected(){
		std::stringstream ss;
		ss  << "Logikai kifejezés várok"  << std::endl ; 
		error(ss);

	}
        void errorNumberIdentifierExpected(){
		std::stringstream ss;
		ss  << "Egész típusú változót várok"  << std::endl ; 
		error(ss);

	}


    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
        void print__();
        void exceptionHandler__(std::exception const &exc);
};
#endif
